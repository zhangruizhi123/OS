#include <stdio.h>
#include <stdlib.h>

//判断是否编译linux下还是windows下的程序
#define LINUX 1


#ifdef WINDWOS 
#include <windows.h>
#else
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>

#endif


typedef struct program_h_t{
	int h1;
	int h2;
	int h3;
	int h4;
	int h5;
	int h6;
	int h7;
	int h8;
}program_h_t;

void createImg();
//读取ELF文件 
void readELF(char*files,char*img);
//将启动文件写入镜像文件 
void readBOOT(char*files,char*img);

//#define TEST 0
int main(int argc, char *argv[]) {
	
	#ifdef TEST
	#else
	createImg("abc.img");
	readELF("kernel.bin","abc.img");
	readBOOT("boot","abc.img");
	#endif
	return 0;
}

void readBOOT(char*files,char*img)
{

#ifdef WINDOWs
	HANDLE hFile = CreateFile(files,GENERIC_WRITE | GENERIC_READ,0,NULL, OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,NULL);  
	HANDLE imgFile = CreateFile(img,GENERIC_WRITE | GENERIC_READ,0,NULL, OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,NULL); 
	DWORD readSize = 0;                // 模板文件为空。  
    if (hFile == INVALID_HANDLE_VALUE)  
    {  
        printf("打开ELF文件失败\n");
    }  
    if (imgFile == INVALID_HANDLE_VALUE)  
    {  
        printf("打开IMG文件失败\n");
    } 
    
    char content[512]={0};
    BOOL result;
    SetFilePointer(hFile,0,NULL,FILE_BEGIN);
    result=ReadFile(hFile,content,512,&readSize,NULL);
    if(result&&readSize==512)
    {
    	SetFilePointer(imgFile,0,NULL,FILE_BEGIN);
    	result=WriteFile(imgFile, content, 512, &readSize, NULL);  
    	if(result&&readSize==512)
    	{
    		printf("写入成功\n");
		}
		else
		{
			printf("写入失败\n");
		 } 
	}
	else
	{
		printf("读取镜像失败\n");
	}
	CloseHandle(hFile) ;
    CloseHandle(imgFile) ;

#else 

#endif
	
}
void readELF(char*files,char*img)
{

#ifdef WINDOWS
	HANDLE hFile = CreateFile(files,GENERIC_WRITE | GENERIC_READ,0,NULL, OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,NULL);  
	HANDLE imgFile = CreateFile(img,GENERIC_WRITE | GENERIC_READ,0,NULL, OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,NULL); 
	DWORD readSize = 0;                // 模板文件为空。  
    if (hFile == INVALID_HANDLE_VALUE)  
    {  
        printf("打开ELF文件失败\n");
    }  
    if (imgFile == INVALID_HANDLE_VALUE)  
    {  
        printf("打开IMG文件失败\n");
    }  
    char type[4];
    BOOL result;
    result=ReadFile(hFile,type,4,&readSize,NULL);
    if(!result)
    {
    	printf("读取失败\n");
	}
	if(!(type[1]=='E'&&type[2]=='L'&&type[3]=='F'))
	{
		printf("该文件不是ELF文件!\n");
		return;
	}
	//程序入口地址 
	int p_entry; 
	
	SetFilePointer(hFile,0x18,NULL,FILE_BEGIN);
    result=ReadFile(hFile,&p_entry,sizeof(int),&readSize,NULL);
    printf("程序入口地址：0x%x\n",p_entry);
	//节开始的位置 
	SetFilePointer(hFile,0x1c,NULL,FILE_BEGIN);
    int p_start=0;
    result=ReadFile(hFile,&p_start,sizeof(int),&readSize,NULL);
    printf("节的开始地址：0x%x\n",p_start);
    //获取节的大小 
   	short p_size=0;
   	SetFilePointer(hFile,0x2a,NULL,FILE_BEGIN);
   	result=ReadFile(hFile,&p_size,sizeof(short),&readSize,NULL);
   	printf("节的大小：0x%x\n",p_size);
   	//获取节的个数
	short  p_number=0;
	SetFilePointer(hFile,0x2c,NULL,FILE_BEGIN);
   	result=ReadFile(hFile,&p_number,sizeof(short),&readSize,NULL);
   	printf("节的个数：0x%x\n",p_number);
   	
   	printf("----------------------------------------\n");
   	//循环读取每个节的信息
   	int rel_addr=0;//获取每个节的首地址 
   	int i=0;
   	char*content;//文件中节的大小 
   	program_h_t p_h;
	for(i=0;i<p_number;i++)
	{
	   	rel_addr=p_start+i*p_size;
	   	printf("节%d的开始地址:0x%x\n",i+1,rel_addr);
	   	SetFilePointer(hFile,rel_addr,NULL,FILE_BEGIN);
	   	result=ReadFile(hFile,&p_h,sizeof(program_h_t),&readSize,NULL);
	   	printf("在文件中偏移:0x%x\n",p_h.h2);
	   	printf("在内存中偏移:0x%x\n",p_h.h3);
	   	printf("在文件中长度:0x%x\n",p_h.h5);
	   	printf("在内存中长度:0x%x\n",p_h.h6);
	   
	   	if(p_h.h5==0)
		{
	   		printf("无需读写.\n");
	   		printf("      ----------------\n");
	   		continue;
		}
	   	//创建文件中的长度大小 
	   	char*content=(char*)malloc(p_h.h5);
	   	//设置文件中的偏移 
	   	SetFilePointer(hFile,p_h.h2,NULL,FILE_BEGIN);
	   	//读取文件
		result=ReadFile(hFile,content,p_h.h5,&readSize,NULL);
		if(result&&readSize==p_h.h6)
		{
			SetFilePointer(imgFile,p_h.h3,NULL,FILE_BEGIN);
			result=WriteFile(imgFile, content, p_h.h5, &readSize, NULL);  
			if(!(result&&readSize== p_h.h5))
			{
				printf("写入IMG文件失败!\n");
			}
			else
			{
				printf("写入IMG文件成功!\n");
			}
		}
		else
		{
			printf("读取文件失败%d，%d，%d\n",result,p_h.h5,readSize);
		}
	   	printf("      ----------------\n");
	   	
	} 
	CloseHandle(hFile) ;
    CloseHandle(imgFile) ;

#else 
#endif
}
//创建一个镜像文件 
void createImg(char*name)
{

#ifdef WINDOWS
		HANDLE hFile = CreateFile(name,     //创建文件的名称。  
        GENERIC_WRITE | GENERIC_READ,          // 写和读文件。  
        0,                      // 不共享读写。  
        NULL,                   // 缺省安全属性。  
        OPEN_EXISTING,          // CREATE_ALWAYS  覆盖文件（不存在则创建）    OPEN_EXISTING 打开文件（不存在则报错）  
        FILE_ATTRIBUTE_NORMAL, // 一般的文件。         
        NULL);                 // 模板文件为空。  
    if (hFile == INVALID_HANDLE_VALUE)  
    {  
        printf("打开文件失败\n");
    }  
    char content[1024*1024]={0};
    DWORD dwWritenSize = 0;  
    BOOL bRet = WriteFile(hFile, content, 1024*1024, &dwWritenSize, NULL);  
    if (bRet)  
    {  
       printf("写入文件失败\n");
    }  
    CloseHandle(hFile) ;
#else 
	int fd=open(name,O_CREAT|O_RDWR);
	size_t size;
	if(fd==-1)
	{
		printf("打开文件失败\n");
		return;
	}  
	char buff[1024*1024]={0};
	size=write(fd,buff,1024*1024);
	if (size!=1024*1024)
	{
		printf("创建文件失败\n");
	}
	else
	{
		printf("创建文件 %s 成功\n",name);
	}
	close(fd);

#endif
}

